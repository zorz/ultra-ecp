/**
 * CompactionService - Agent-Aware Context Compaction
 *
 * Manages context window compaction with awareness of multiple agents.
 * Ensures important messages from each agent are preserved proportionally.
 */

import { Database } from 'bun:sqlite';
import type { MessageStore, IStoredMessage } from '../stores/MessageStore.ts';
import type { SessionStore } from '../stores/SessionStore.ts';
import type { IAgent } from '../types/agents.ts';

/**
 * Compaction record stored in the database.
 */
export interface IStoredCompaction {
  id: string;
  sessionId: string;
  summary: string;
  startMessageId: string;
  endMessageId: string;
  messageCount: number;
  tokensBefore: number | null;
  tokensAfter: number | null;
  createdAt: number;
  isActive: boolean;
  expandedAt: number | null;
  /** Agents whose messages were included in this compaction */
  agentIds: string[];
}

/**
 * Options for creating a compaction.
 */
export interface ICreateCompactionOptions {
  sessionId: string;
  /** Summary text generated by AI */
  summary: string;
  /** First message ID in the compaction range */
  startMessageId: string;
  /** Last message ID in the compaction range */
  endMessageId: string;
  /** Number of messages being compacted */
  messageCount: number;
  /** Estimated tokens before compaction */
  tokensBefore?: number;
  /** Estimated tokens after compaction (summary size) */
  tokensAfter?: number;
  /** Agent IDs whose messages are included */
  agentIds?: string[];
}

/**
 * Result of selecting messages for compaction.
 */
export interface ICompactionSelection {
  /** Messages to include in compaction */
  messagesToCompact: IStoredMessage[];
  /** Messages to keep in full */
  messagesToKeep: IStoredMessage[];
  /** Breakdown by agent */
  agentBreakdown: Map<string, { total: number; compacted: number; kept: number }>;
}

/**
 * Options for building a compaction summary.
 */
export interface IBuildSummaryOptions {
  sessionId: string;
  messages: IStoredMessage[];
  agents?: IAgent[];
}

/**
 * Prompt for generating agent-aware summaries.
 */
const AGENT_AWARE_COMPACTION_PROMPT = `Summarize this multi-agent conversation for context continuity. Focus on:

## Participants
- Note which agents participated in this conversation
- Summarize each agent's key contributions and areas of focus

## Key Decisions
- Important choices made during this conversation
- Approaches selected, alternatives rejected
- Who made or influenced each decision

## Files Modified
- List files that were created, edited, or deleted
- Include brief description of changes
- Note which agent made the modifications

## Current State
- What task is in progress?
- What was the last thing accomplished?
- Any pending issues or blockers?
- Which agent is currently working on what?

## Agent Handoffs
- Note any handoffs between agents
- Record pending work that needs agent attention

Keep the summary concise but complete. This will replace the older messages
in the AI's context, so include anything important for continuity.
Preserve key contributions from each agent to maintain multi-agent context.`;

/**
 * CompactionService handles context compaction with multi-agent awareness.
 */
export class CompactionService {
  private db: Database;

  constructor(
    private messageStore: MessageStore,
    private sessionStore: SessionStore,
    db: Database
  ) {
    this.db = db;
  }

  /**
   * Select messages for compaction while preserving agent representation.
   * Keeps the most recent N messages and ensures each agent's most
   * important contributions are preserved proportionally.
   */
  selectMessagesForCompaction(
    sessionId: string,
    options: {
      keepRecentCount?: number;
      maxTokens?: number;
    } = {}
  ): ICompactionSelection {
    const { keepRecentCount = 10, maxTokens } = options;

    // Get all messages for the session
    const allMessages = this.messageStore.listBySession(sessionId, { limit: 1000 });

    if (allMessages.length <= keepRecentCount) {
      return {
        messagesToCompact: [],
        messagesToKeep: allMessages,
        agentBreakdown: new Map(),
      };
    }

    // Split into compact vs keep
    const messagesToKeep = allMessages.slice(-keepRecentCount);
    let messagesToCompact = allMessages.slice(0, -keepRecentCount);

    // If maxTokens specified, reduce further
    if (maxTokens) {
      const keepTokens = this.estimateTokens(messagesToKeep);
      const targetCompactTokens = maxTokens - keepTokens;

      if (targetCompactTokens > 0) {
        // Keep only messages that fit in token budget
        let currentTokens = 0;
        const reducedCompact: IStoredMessage[] = [];

        for (const msg of messagesToCompact) {
          const msgTokens = this.estimateMessageTokens(msg);
          if (currentTokens + msgTokens > targetCompactTokens) break;
          reducedCompact.push(msg);
          currentTokens += msgTokens;
        }

        messagesToCompact = reducedCompact;
      }
    }

    // Calculate agent breakdown
    const agentBreakdown = new Map<string, { total: number; compacted: number; kept: number }>();

    for (const msg of allMessages) {
      const agentId = msg.agentId || 'user';
      if (!agentBreakdown.has(agentId)) {
        agentBreakdown.set(agentId, { total: 0, compacted: 0, kept: 0 });
      }
      agentBreakdown.get(agentId)!.total++;
    }

    for (const msg of messagesToCompact) {
      const agentId = msg.agentId || 'user';
      agentBreakdown.get(agentId)!.compacted++;
    }

    for (const msg of messagesToKeep) {
      const agentId = msg.agentId || 'user';
      agentBreakdown.get(agentId)!.kept++;
    }

    return {
      messagesToCompact,
      messagesToKeep,
      agentBreakdown,
    };
  }

  /**
   * Build the conversation text for summarization with agent attribution.
   */
  buildConversationText(messages: IStoredMessage[]): string {
    return messages
      .filter(m => m.role !== 'system')
      .map(m => {
        const agentPrefix = m.agentName ? `[${m.agentName}] ` : '';
        return `${m.role.toUpperCase()} ${agentPrefix}: ${m.content}`;
      })
      .join('\n\n');
  }

  /**
   * Get the compaction prompt (agent-aware).
   */
  getCompactionPrompt(): string {
    return AGENT_AWARE_COMPACTION_PROMPT;
  }

  /**
   * Create a compaction record.
   */
  createCompaction(options: ICreateCompactionOptions): IStoredCompaction {
    const now = Date.now();
    const id = `compaction-${crypto.randomUUID()}`;

    const compaction: IStoredCompaction = {
      id,
      sessionId: options.sessionId,
      summary: options.summary,
      startMessageId: options.startMessageId,
      endMessageId: options.endMessageId,
      messageCount: options.messageCount,
      tokensBefore: options.tokensBefore ?? null,
      tokensAfter: options.tokensAfter ?? null,
      createdAt: now,
      isActive: true,
      expandedAt: null,
      agentIds: options.agentIds ?? [],
    };

    // Store in database
    this.db.run(
      `INSERT INTO chat_compactions (id, session_id, summary, start_message_id, end_message_id, message_count, tokens_before, tokens_after, created_at, is_active, expanded_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        compaction.id,
        compaction.sessionId,
        compaction.summary,
        compaction.startMessageId,
        compaction.endMessageId,
        compaction.messageCount,
        compaction.tokensBefore,
        compaction.tokensAfter,
        compaction.createdAt,
        compaction.isActive ? 1 : 0,
        compaction.expandedAt,
      ]
    );

    return compaction;
  }

  /**
   * Get active compactions for a session.
   */
  getActiveCompactions(sessionId: string): IStoredCompaction[] {
    const rows = this.db.query(`
      SELECT id, session_id, summary, start_message_id, end_message_id, message_count,
             tokens_before, tokens_after, created_at, is_active, expanded_at
      FROM chat_compactions
      WHERE session_id = ? AND is_active = 1
      ORDER BY created_at ASC
    `).all(sessionId) as Array<Record<string, unknown>>;

    return rows.map(row => this.mapRow(row));
  }

  /**
   * Get all compactions for a session.
   */
  getAllCompactions(sessionId: string): IStoredCompaction[] {
    const rows = this.db.query(`
      SELECT id, session_id, summary, start_message_id, end_message_id, message_count,
             tokens_before, tokens_after, created_at, is_active, expanded_at
      FROM chat_compactions
      WHERE session_id = ?
      ORDER BY created_at ASC
    `).all(sessionId) as Array<Record<string, unknown>>;

    return rows.map(row => this.mapRow(row));
  }

  /**
   * Expand a compaction (show original messages).
   */
  expandCompaction(id: string): void {
    const now = Date.now();
    this.db.run(
      'UPDATE chat_compactions SET is_active = 0, expanded_at = ? WHERE id = ?',
      [now, id]
    );
  }

  /**
   * Collapse a compaction (use summary).
   */
  collapseCompaction(id: string): void {
    this.db.run(
      'UPDATE chat_compactions SET is_active = 1, expanded_at = NULL WHERE id = ?',
      [id]
    );
  }

  /**
   * Delete a compaction.
   */
  deleteCompaction(id: string): void {
    this.db.run('DELETE FROM chat_compactions WHERE id = ?', [id]);
  }

  /**
   * Get message IDs within a compaction range.
   */
  getCompactedMessageIds(sessionId: string, startMessageId: string, endMessageId: string): string[] {
    // Get the created_at timestamps for the boundary messages
    const startMsg = this.messageStore.get(startMessageId);
    const endMsg = this.messageStore.get(endMessageId);

    if (!startMsg || !endMsg) {
      return [];
    }

    const rows = this.db.query(`
      SELECT id FROM chat_messages
      WHERE session_id = ?
        AND created_at >= ?
        AND created_at <= ?
      ORDER BY created_at ASC
    `).all(sessionId, startMsg.createdAt, endMsg.createdAt) as Array<{ id: string }>;

    return rows.map(r => r.id);
  }

  /**
   * Estimate tokens for a list of messages.
   */
  estimateTokens(messages: IStoredMessage[]): number {
    return messages.reduce((sum, m) => sum + this.estimateMessageTokens(m), 0);
  }

  /**
   * Estimate tokens for a single message.
   */
  estimateMessageTokens(message: IStoredMessage): number {
    return Math.ceil(message.content.length / 4);
  }

  /**
   * Build curated context with compactions applied.
   */
  buildCuratedContext(
    sessionId: string,
    options: { includeExpanded?: boolean } = {}
  ): {
    messages: IStoredMessage[];
    totalTokens: number;
    compactionsApplied: number;
    hasCompactedContent: boolean;
  } {
    const { includeExpanded = false } = options;

    // Get all messages
    const allMessages = this.messageStore.listBySession(sessionId, { limit: 1000 });

    // If showing expanded view, return all messages
    if (includeExpanded) {
      const totalTokens = this.estimateTokens(allMessages);
      return {
        messages: allMessages,
        totalTokens,
        compactionsApplied: 0,
        hasCompactedContent: false,
      };
    }

    // Get active compactions
    const compactions = this.getActiveCompactions(sessionId);

    if (compactions.length === 0) {
      const totalTokens = this.estimateTokens(allMessages);
      return {
        messages: allMessages,
        totalTokens,
        compactionsApplied: 0,
        hasCompactedContent: false,
      };
    }

    // Build set of compacted message IDs
    const compactedIds = new Set<string>();
    for (const compaction of compactions) {
      const ids = this.getCompactedMessageIds(
        sessionId,
        compaction.startMessageId,
        compaction.endMessageId
      );
      ids.forEach(id => compactedIds.add(id));
    }

    // Build curated context
    const curatedMessages: IStoredMessage[] = [];
    let compactionIndex = 0;

    for (const msg of allMessages) {
      // Check if this message starts a compaction range
      const currentCompaction = compactions[compactionIndex];
      if (currentCompaction && msg.id === currentCompaction.startMessageId) {
        // Insert the summary message
        curatedMessages.push({
          id: `summary-${currentCompaction.id}`,
          sessionId,
          role: 'system',
          content: `## Context Summary (${currentCompaction.messageCount} messages compacted)\n\n${currentCompaction.summary}`,
          model: null,
          inputTokens: null,
          outputTokens: null,
          durationMs: null,
          agentId: null,
          agentName: null,
          createdAt: currentCompaction.createdAt,
        });
        compactionIndex++;
      }

      // Skip compacted messages
      if (compactedIds.has(msg.id)) {
        continue;
      }

      curatedMessages.push(msg);
    }

    const totalTokens = this.estimateTokens(curatedMessages);

    return {
      messages: curatedMessages,
      totalTokens,
      compactionsApplied: compactions.length,
      hasCompactedContent: true,
    };
  }

  /**
   * Map a database row to a compaction object.
   */
  private mapRow(row: Record<string, unknown>): IStoredCompaction {
    return {
      id: row.id as string,
      sessionId: row.session_id as string,
      summary: row.summary as string,
      startMessageId: row.start_message_id as string,
      endMessageId: row.end_message_id as string,
      messageCount: row.message_count as number,
      tokensBefore: row.tokens_before as number | null,
      tokensAfter: row.tokens_after as number | null,
      createdAt: row.created_at as number,
      isActive: Boolean(row.is_active),
      expandedAt: row.expanded_at as number | null,
      agentIds: [], // TODO: Store and retrieve agent IDs
    };
  }
}

/**
 * Create a new CompactionService instance.
 */
export function createCompactionService(
  messageStore: MessageStore,
  sessionStore: SessionStore,
  db: Database
): CompactionService {
  return new CompactionService(messageStore, sessionStore, db);
}
