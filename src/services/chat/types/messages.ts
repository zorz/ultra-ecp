/**
 * Unified Message Type Hierarchy
 *
 * Provides a clear inheritance structure for all message types in the chat system.
 * This replaces the fragmented type definitions with a coherent hierarchy.
 */

/**
 * Content block types for structured message content.
 */
export interface ITextBlock {
  type: 'text';
  text: string;
}

export interface IToolUseBlock {
  type: 'tool_use';
  id: string;
  name: string;
  input: unknown;
}

export interface IToolResultBlock {
  type: 'tool_result';
  tool_use_id: string;
  content: string | Array<{ type: 'text'; text: string }>;
  is_error?: boolean;
}

export interface IImageBlock {
  type: 'image';
  source: {
    type: 'base64';
    media_type: string;
    data: string;
  };
}

export type IContentBlock = ITextBlock | IToolUseBlock | IToolResultBlock | IImageBlock;

/**
 * Usage statistics for API calls.
 */
export interface IUsageStats {
  inputTokens: number;
  outputTokens: number;
  cacheCreationInputTokens?: number;
  cacheReadInputTokens?: number;
}

/**
 * Base message - common fields for all messages.
 */
export interface IBaseMessage {
  /** Unique message identifier */
  id: string;
  /** Message role */
  role: 'user' | 'assistant' | 'system';
  /** Unix timestamp in milliseconds */
  timestamp: number;
  /** Optional metadata for extensions */
  metadata?: Record<string, unknown>;
}

/**
 * Content message - has actual content (text or blocks).
 */
export interface IContentMessage extends IBaseMessage {
  /** Message content - string for simple text, blocks for rich content */
  content: string | IContentBlock[];
}

/**
 * Session message - tied to a specific chat session.
 */
export interface ISessionMessage extends IContentMessage {
  /** Session this message belongs to */
  sessionId: string;
  /** Turn index within the session (for ordering) */
  turnIndex?: number;
}

/**
 * User message - sent by the human user.
 */
export interface IUserMessage extends ISessionMessage {
  role: 'user';
}

/**
 * Tool use reference within an assistant message.
 */
export interface IToolUse {
  id: string;
  name: string;
  input: unknown;
  /** Status of the tool execution */
  status?: 'pending' | 'approved' | 'denied' | 'success' | 'error';
  /** Output from the tool (if completed) */
  output?: unknown;
  /** Error message (if failed) */
  errorMessage?: string;
}

/**
 * Assistant message - generated by the AI model.
 */
export interface IAssistantMessage extends ISessionMessage {
  role: 'assistant';
  /** Model that generated this message */
  model?: string;
  /** Why the model stopped generating */
  stopReason?: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';
  /** Token usage for this response */
  usage?: IUsageStats;
  /** Tool uses within this message */
  toolUses?: IToolUse[];
  /** Duration in ms for generating this response */
  durationMs?: number;
}

/**
 * Tool result message - result of a tool execution.
 * Note: Tool results are sent as user messages in the API.
 */
export interface IToolResultMessage extends ISessionMessage {
  role: 'user';
  /** ID of this tool result */
  toolResultId: string;
  /** ID of the tool use this is responding to */
  toolUseId: string;
  /** Whether the tool execution failed */
  isError?: boolean;
}

/**
 * System message - instructions or context for the AI.
 */
export interface ISystemMessage extends ISessionMessage {
  role: 'system';
}

/**
 * Agent message - for multi-agent orchestration.
 * Extends assistant message with agent-specific fields.
 */
export interface IAgentMessage extends IAssistantMessage {
  /** Unique identifier for this agent */
  agentId: string;
  /** Role of this agent in the conversation */
  agentRole: 'primary' | 'specialist' | 'reviewer' | 'orchestrator';
  /** If this is a delegated task, the parent agent ID */
  delegatedFrom?: string;
  /** If this agent delegated to others, their IDs */
  delegatedTo?: string[];
  /** Agent-specific capabilities or constraints */
  capabilities?: string[];
}

/**
 * Streaming message - partial message during streaming.
 */
export interface IStreamingMessage extends Partial<IAssistantMessage> {
  /** Whether this is a streaming (incomplete) message */
  isStreaming: true;
  /** Partial text accumulated so far */
  partialText?: string;
  /** Partial tool uses being built */
  partialToolUses?: Array<Partial<IToolUse>>;
}

/**
 * Any message type in the system.
 */
export type IAnyMessage =
  | IUserMessage
  | IAssistantMessage
  | IToolResultMessage
  | ISystemMessage
  | IAgentMessage;

/**
 * Type guard for user messages.
 */
export function isUserMessage(msg: IBaseMessage): msg is IUserMessage {
  return msg.role === 'user' && !('toolResultId' in msg);
}

/**
 * Type guard for assistant messages.
 */
export function isAssistantMessage(msg: IBaseMessage): msg is IAssistantMessage {
  return msg.role === 'assistant';
}

/**
 * Type guard for tool result messages.
 */
export function isToolResultMessage(msg: IBaseMessage): msg is IToolResultMessage {
  return msg.role === 'user' && 'toolResultId' in msg;
}

/**
 * Type guard for agent messages.
 */
export function isAgentMessage(msg: IBaseMessage): msg is IAgentMessage {
  return msg.role === 'assistant' && 'agentId' in msg;
}

/**
 * Type guard for streaming messages.
 */
export function isStreamingMessage(msg: unknown): msg is IStreamingMessage {
  return typeof msg === 'object' && msg !== null && 'isStreaming' in msg && (msg as IStreamingMessage).isStreaming === true;
}

/**
 * Extract text content from a message.
 */
export function getMessageText(msg: IContentMessage): string {
  if (typeof msg.content === 'string') {
    return msg.content;
  }

  return msg.content
    .filter((block): block is ITextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('');
}

/**
 * Extract tool uses from a message.
 */
export function getToolUses(msg: IContentMessage): IToolUseBlock[] {
  if (typeof msg.content === 'string') {
    return [];
  }

  return msg.content.filter((block): block is IToolUseBlock => block.type === 'tool_use');
}
